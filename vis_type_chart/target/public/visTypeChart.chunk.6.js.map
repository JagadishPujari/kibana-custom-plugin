{"version":3,"file":"visTypeChart.chunk.6.js","sources":["/plugin:visTypeChart/node_modules/compare-versions/index.js","/plugin:visTypeChart/node_modules/vega-schema-url-parser/dist/parser.js","/plugin:visTypeChart/src/plugins/vis_type_chart/public/chart_view/chart_view.js","/plugin:visTypeChart/src/plugins/vis_type_chart/public/data_model/chart_parser.ts","/plugin:visTypeChart/src/plugins/vis_type_chart/public/data_model/ems_file_parser.ts","/plugin:visTypeChart/src/plugins/vis_type_chart/public/data_model/es_query_parser.ts","/plugin:visTypeChart/src/plugins/vis_type_chart/public/data_model/url_parser.ts"],"sourcesContent":["/* global define */\n(function (root, factory) {\n  /* istanbul ignore next */\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.compareVersions = factory();\n  }\n}(this, function () {\n\n  var semver = /^v?(?:\\d+)(\\.(?:[x*]|\\d+)(\\.(?:[x*]|\\d+)(\\.(?:[x*]|\\d+))?(?:-[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\n\n  function indexOrEnd(str, q) {\n    return str.indexOf(q) === -1 ? str.length : str.indexOf(q);\n  }\n\n  function split(v) {\n    var c = v.replace(/^v/, '').replace(/\\+.*$/, '');\n    var patchIndex = indexOrEnd(c, '-');\n    var arr = c.substring(0, patchIndex).split('.');\n    arr.push(c.substring(patchIndex + 1));\n    return arr;\n  }\n\n  function tryParse(v) {\n    return isNaN(Number(v)) ? v : Number(v);\n  }\n\n  function validate(version) {\n    if (typeof version !== 'string') {\n      throw new TypeError('Invalid argument expected string');\n    }\n    if (!semver.test(version)) {\n      throw new Error('Invalid argument not valid semver (\\''+version+'\\' received)');\n    }\n  }\n\n  function compareVersions(v1, v2) {\n    [v1, v2].forEach(validate);\n\n    var s1 = split(v1);\n    var s2 = split(v2);\n\n    for (var i = 0; i < Math.max(s1.length - 1, s2.length - 1); i++) {\n      var n1 = parseInt(s1[i] || 0, 10);\n      var n2 = parseInt(s2[i] || 0, 10);\n\n      if (n1 > n2) return 1;\n      if (n2 > n1) return -1;\n    }\n\n    var sp1 = s1[s1.length - 1];\n    var sp2 = s2[s2.length - 1];\n\n    if (sp1 && sp2) {\n      var p1 = sp1.split('.').map(tryParse);\n      var p2 = sp2.split('.').map(tryParse);\n\n      for (i = 0; i < Math.max(p1.length, p2.length); i++) {\n        if (p1[i] === undefined || typeof p2[i] === 'string' && typeof p1[i] === 'number') return -1;\n        if (p2[i] === undefined || typeof p1[i] === 'string' && typeof p2[i] === 'number') return 1;\n\n        if (p1[i] > p2[i]) return 1;\n        if (p2[i] > p1[i]) return -1;\n      }\n    } else if (sp1 || sp2) {\n      return sp1 ? -1 : 1;\n    }\n\n    return 0;\n  };\n\n  var allowedOperators = [\n    '>',\n    '>=',\n    '=',\n    '<',\n    '<='\n  ];\n\n  var operatorResMap = {\n    '>': [1],\n    '>=': [0, 1],\n    '=': [0],\n    '<=': [-1, 0],\n    '<': [-1]\n  };\n\n  function validateOperator(op) {\n    if (typeof op !== 'string') {\n      throw new TypeError('Invalid operator type, expected string but got ' + typeof op);\n    }\n    if (allowedOperators.indexOf(op) === -1) {\n      throw new TypeError('Invalid operator, expected one of ' + allowedOperators.join('|'));\n    }\n  }\n\n  compareVersions.compare = function (v1, v2, operator) {\n    // Validate operator\n    validateOperator(operator);\n\n    // since result of compareVersions can only be -1 or 0 or 1\n    // a simple map can be used to replace switch\n    var res = compareVersions(v1, v2);\n    return operatorResMap[operator].indexOf(res) > -1;\n  }\n\n  return compareVersions;\n}));\n","module.exports=function(e){const[n,o]=/\\/schema\\/([\\w-]+)\\/([\\w\\.\\-]+)\\.json$/g.exec(e).slice(1,3);return{library:n,version:o}};\n//# sourceMappingURL=parser.js.map\n","/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\nimport { View, parse } from 'vega';\nimport { ChartBaseView } from './chart_base_view';\nexport class ChartView extends ChartBaseView {\n  async _initViewCustomizations() {\n    // In some cases, Chart may be initialized twice... TBD\n    if (!this._$container) return;\n    const view = new View(parse(this._parser.spec, undefined, {\n      ast: true\n    }), this._chartViewConfig);\n    if (this._parser.useResize) this.updateChartSize(view);\n    view.initialize(this._$container.get(0), this._$controls.get(0));\n    if (this._parser.useHover) view.hover();\n    await this.setView(view);\n    this.setDebugValues(view, this._parser.spec, this._parser.vlspec);\n  }\n\n}","function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\nimport _ from 'lodash';\nimport schemaParser from 'vega-schema-url-parser';\nimport versionCompare from 'compare-versions';\nimport hjson from 'hjson';\nimport { euiPaletteColorBlind } from '@elastic/eui';\nimport { euiThemeVars } from '@kbn/ui-shared-deps/theme';\nimport { i18n } from '@kbn/i18n';\nimport { logger, Warn, None, version as vegaVersion } from 'vega';\nimport { compile, version as vegaLiteVersion } from 'vega-lite';\nimport { EsQueryParser } from './es_query_parser';\nimport { Utils } from './utils';\nimport { EmsFileParser } from './ems_file_parser';\nimport { UrlParser } from './url_parser';\n// Set default single color to match other Kibana visualizations\nconst defaultColor = euiPaletteColorBlind()[0];\nconst locToDirMap = {\n  left: 'row-reverse',\n  right: 'row',\n  top: 'column-reverse',\n  bottom: 'column'\n}; // If there is no \"%type%\" parameter, use this parser\n\nconst DEFAULT_PARSER = 'elasticsearch';\nexport class ChartParser {\n  constructor(spec, searchAPI, timeCache, filters, getServiceSettings) {\n    _defineProperty(this, \"spec\", void 0);\n\n    _defineProperty(this, \"hideWarnings\", void 0);\n\n    _defineProperty(this, \"restoreSignalValuesOnRefresh\", void 0);\n\n    _defineProperty(this, \"error\", void 0);\n\n    _defineProperty(this, \"warnings\", void 0);\n\n    _defineProperty(this, \"_urlParsers\", void 0);\n\n    _defineProperty(this, \"isVegaLite\", void 0);\n\n    _defineProperty(this, \"useHover\", void 0);\n\n    _defineProperty(this, \"_config\", void 0);\n\n    _defineProperty(this, \"useMap\", void 0);\n\n    _defineProperty(this, \"renderer\", void 0);\n\n    _defineProperty(this, \"tooltips\", void 0);\n\n    _defineProperty(this, \"mapConfig\", void 0);\n\n    _defineProperty(this, \"vlspec\", void 0);\n\n    _defineProperty(this, \"useResize\", void 0);\n\n    _defineProperty(this, \"containerDir\", void 0);\n\n    _defineProperty(this, \"controlsDir\", void 0);\n\n    _defineProperty(this, \"searchAPI\", void 0);\n\n    _defineProperty(this, \"getServiceSettings\", void 0);\n\n    _defineProperty(this, \"filters\", void 0);\n\n    _defineProperty(this, \"timeCache\", void 0);\n\n    this.spec = spec;\n    this.hideWarnings = false;\n    this.error = undefined;\n    this.warnings = [];\n    this.searchAPI = searchAPI;\n    this.getServiceSettings = getServiceSettings;\n    this.filters = filters;\n    this.timeCache = timeCache;\n  }\n\n  async parseAsync() {\n    try {\n      await this._parseAsync();\n    } catch (err) {\n      // if we reject current promise, it will use the standard Kibana error handling\n      this.error = Utils.formatErrorToStr(err);\n    }\n\n    return this;\n  }\n\n  async _parseAsync() {\n    if (this.isVegaLite !== undefined) throw new Error();\n\n    if (typeof this.spec === 'string') {\n      const spec = hjson.parse(this.spec, {\n        legacyRoot: false\n      });\n\n      if (!spec.$schema) {\n        throw new Error(i18n.translate('visTypeVega.vegaParser.inputSpecDoesNotSpecifySchemaErrorMessage', {\n          defaultMessage: `Your specification requires a {schemaParam} field with a valid URL for\nVega (see {vegaSchemaUrl}) or\nVega-Lite (see {vegaLiteSchemaUrl}).\nThe URL is an identifier only. Kibana and your browser will never access this URL.`,\n          values: {\n            schemaParam: '\"$schema\"',\n            vegaLiteSchemaUrl: 'https://vega.github.io/vega-lite/docs/spec.html#top-level',\n            vegaSchemaUrl: 'https://vega.github.io/vega/docs/specification/#top-level-specification-properties'\n          }\n        }));\n      }\n\n      this.spec = spec;\n    }\n\n    if (!_.isPlainObject(this.spec)) {\n      throw new Error(i18n.translate('visTypeVega.vegaParser.invalidVegaSpecErrorMessage', {\n        defaultMessage: 'Invalid Vega specification'\n      }));\n    }\n\n    this.isVegaLite = this.parseSchema(this.spec).isVegaLite;\n    this.useHover = !this.isVegaLite;\n    this._config = this._parseConfig();\n    this.hideWarnings = !!this._config.hideWarnings;\n\n    this._parseBool('restoreSignalValuesOnRefresh', this._config, false);\n\n    this.restoreSignalValuesOnRefresh = this._config.restoreSignalValuesOnRefresh;\n    this.useMap = this._config.type === 'map';\n    this.renderer = this._config.renderer === 'svg' ? 'svg' : 'canvas';\n    this.tooltips = this._parseTooltips();\n\n    this._setDefaultColors();\n\n    this._parseControlPlacement();\n\n    if (this.useMap) {\n      this.mapConfig = this._parseMapConfig();\n      this.useResize = false;\n    }\n\n    await this._resolveDataUrls();\n\n    if (this.isVegaLite) {\n      this._compileVegaLite();\n    } else {\n      this._compileWithAutosize();\n    }\n  }\n  /**\n   * Ensure that Vega and Vega-Lite will take the full width of the container unless\n   * the user has explicitly disabled this setting by setting it to \"none\".\n   * Also sets the default width to include the padding. This creates the least configuration\n   * needed for most cases, with the option to do more.\n   */\n\n\n  _compileWithAutosize() {\n    const defaultAutosize = {\n      type: 'fit',\n      contains: 'padding'\n    };\n    let autosize = this.spec.autosize;\n    let useResize = true;\n\n    if (!this.isVegaLite && autosize && typeof autosize === 'object' && 'signal' in autosize) {\n      // Vega supports dynamic autosize information, so we ignore it\n      return;\n    }\n\n    if (!autosize && typeof autosize !== 'undefined') {\n      this._onWarning(i18n.translate('visTypeVega.vegaParser.autoSizeDoesNotAllowFalse', {\n        defaultMessage: '{autoSizeParam} is enabled, it can only be disabled by setting {autoSizeParam} to {noneParam}',\n        values: {\n          autoSizeParam: '\"autosize\"',\n          noneParam: '\"none\"'\n        }\n      }));\n    }\n\n    if (typeof autosize === 'string') {\n      useResize = autosize !== 'none';\n      autosize = { ...defaultAutosize,\n        type: autosize\n      };\n    } else if (typeof autosize === 'object') {\n      var _autosize, _autosize2;\n\n      autosize = { ...defaultAutosize,\n        ...autosize\n      };\n      useResize = Boolean(((_autosize = autosize) === null || _autosize === void 0 ? void 0 : _autosize.type) && ((_autosize2 = autosize) === null || _autosize2 === void 0 ? void 0 : _autosize2.type) !== 'none');\n    } else {\n      autosize = defaultAutosize;\n    }\n\n    if (useResize && (this.spec.width && this.spec.width !== 'container' || this.spec.height && this.spec.height !== 'container')) {\n      this._onWarning(i18n.translate('visTypeVega.vegaParser.widthAndHeightParamsAreIgnored', {\n        defaultMessage: '{widthParam} and {heightParam} params are ignored because {autoSizeParam} is enabled. Set {autoSizeParam}: {noneParam} to disable',\n        values: {\n          widthParam: '\"width\"',\n          heightParam: '\"height\"',\n          autoSizeParam: '\"autosize\"',\n          noneParam: '\"none\"'\n        }\n      }));\n    }\n\n    if (useResize) {\n      this.spec.width = 'container';\n      this.spec.height = 'container';\n    }\n\n    this.spec.autosize = autosize;\n    this.useResize = useResize;\n  }\n  /**\n   * Convert VegaLite to Vega spec\n   */\n\n\n  _compileVegaLite() {\n    if (!this.useMap) {\n      // Compile without warnings to get the normalized spec, this simplifies the autosize detection\n      const normalized = compile(this.spec, {\n        logger: logger(None)\n      }).normalized; // Vega-Lite allows autosize when there is a single mark or layered chart, but\n      // does not allow autosize for other specs.\n\n      if ('mark' in normalized || 'layer' in normalized) {\n        this._compileWithAutosize();\n      } else {\n        this.useResize = false;\n\n        if (normalized.autosize && typeof normalized.autosize !== 'string' && normalized.autosize.type === 'none') {\n          this._onWarning(i18n.translate('visTypeVega.vegaParser.widthAndHeightParamsAreRequired', {\n            defaultMessage: 'Nothing is rendered when {autoSizeParam} is set to {noneParam} while using faceted or repeated {vegaLiteParam} specs. To fix, remove {autoSizeParam} or use {vegaParam}.',\n            values: {\n              autoSizeParam: '\"autosize\"',\n              noneParam: '\"none\"',\n              vegaLiteParam: 'Vega-Lite',\n              vegaParam: 'Vega'\n            }\n          }));\n        }\n      }\n    }\n\n    this.vlspec = this.spec;\n    const vegaLogger = logger(Warn); // note: eslint has a false positive here\n\n    vegaLogger.warn = this._onWarning.bind(this);\n    this.spec = compile(this.vlspec, {\n      logger: vegaLogger\n    }).spec; // When using VL with the type=map and user did not provid their own projection settings,\n    // remove the default projection that was generated by VegaLite compiler.\n    // This way we let leaflet-vega library inject a different default projection for tile maps.\n    // Also, VL injects default padding and autosize values, but neither should be set for vega-leaflet.\n\n    if (this.useMap) {\n      if (!this.spec || !this.vlspec) return;\n\n      const hasConfig = _.isPlainObject(this.vlspec.config);\n\n      if (this.vlspec.config === undefined || hasConfig && !this.vlspec.config.projection) {\n        // Assume VL generates spec.projections = an array of exactly one object named 'projection'\n        if (!Array.isArray(this.spec.projections) || this.spec.projections.length !== 1 || this.spec.projections[0].name !== 'projection') {\n          throw new Error(i18n.translate('visTypeVega.vegaParser.VLCompilerShouldHaveGeneratedSingleProtectionObjectErrorMessage', {\n            defaultMessage: 'Internal error: Vega-Lite compiler should have generated a single projection object'\n          }));\n        }\n\n        delete this.spec.projections;\n      } // todo: sizing cleanup might need to be rethought and consolidated\n\n\n      if (!this.vlspec.width) delete this.spec.width;\n      if (!this.vlspec.height) delete this.spec.height;\n\n      if (!this.vlspec.padding && (this.vlspec.config === undefined || hasConfig && !this.vlspec.config.padding)) {\n        delete this.spec.padding;\n      }\n\n      if (!this.vlspec.autosize && (this.vlspec.config === undefined || hasConfig && !this.vlspec.config.autosize)) {\n        delete this.spec.autosize;\n      }\n    }\n  }\n  /**\n   * Calculate container-direction CSS property for binding placement\n   * @private\n   */\n\n\n  _parseControlPlacement() {\n    var _this$_config, _this$_config2;\n\n    this.containerDir = (_this$_config = this._config) !== null && _this$_config !== void 0 && _this$_config.controlsLocation ? locToDirMap[this._config.controlsLocation] : undefined;\n\n    if (this.containerDir === undefined) {\n      if (this._config && this._config.controlsLocation === undefined) {\n        this.containerDir = 'column';\n      } else {\n        throw new Error(i18n.translate('visTypeVega.vegaParser.unrecognizedControlsLocationValueErrorMessage', {\n          defaultMessage: 'Unrecognized {controlsLocationParam} value. Expecting one of [{locToDirMap}]',\n          values: {\n            locToDirMap: `\"${Object.keys(locToDirMap).join('\", \"')}\"`,\n            controlsLocationParam: 'controlsLocation'\n          }\n        }));\n      }\n    }\n\n    const dir = (_this$_config2 = this._config) === null || _this$_config2 === void 0 ? void 0 : _this$_config2.controlsDirection;\n\n    if (dir !== undefined && dir !== 'horizontal' && dir !== 'vertical') {\n      throw new Error(i18n.translate('visTypeVega.vegaParser.unrecognizedDirValueErrorMessage', {\n        defaultMessage: 'Unrecognized {dirParam} value. Expecting one of [{expectedValues}]',\n        values: {\n          expectedValues: '\"horizontal\", \"vertical\"',\n          dirParam: 'dir'\n        }\n      }));\n    }\n\n    this.controlsDir = dir === 'horizontal' ? 'row' : 'column';\n  }\n  /**\n   * Parse {config: kibana: {...}} portion of the Vega spec (or root-level _hostConfig for backward compat)\n   * @returns {object} kibana config\n   * @private\n   */\n\n\n  _parseConfig() {\n    let result = null;\n\n    if (this.spec) {\n      if (this.spec._hostConfig !== undefined) {\n        result = this.spec._hostConfig;\n        delete this.spec._hostConfig;\n\n        if (!_.isPlainObject(result)) {\n          throw new Error(i18n.translate('visTypeVega.vegaParser.hostConfigValueTypeErrorMessage', {\n            defaultMessage: 'If present, {configName} must be an object',\n            values: {\n              configName: '\"_hostConfig\"'\n            }\n          }));\n        }\n\n        this._onWarning(i18n.translate('visTypeVega.vegaParser.hostConfigIsDeprecatedWarningMessage', {\n          defaultMessage: '{deprecatedConfigName} has been deprecated. Use {newConfigName} instead.',\n          values: {\n            deprecatedConfigName: '\"_hostConfig\"',\n            newConfigName: 'config.kibana'\n          }\n        }));\n      }\n\n      if (_.isPlainObject(this.spec.config) && this.spec.config.kibana !== undefined) {\n        result = this.spec.config.kibana;\n        delete this.spec.config.kibana;\n\n        if (!_.isPlainObject(result)) {\n          throw new Error(i18n.translate('visTypeVega.vegaParser.kibanaConfigValueTypeErrorMessage', {\n            defaultMessage: 'If present, {configName} must be an object',\n            values: {\n              configName: 'config.kibana'\n            }\n          }));\n        }\n      }\n    }\n\n    return result || {};\n  }\n\n  _parseTooltips() {\n    var _this$_config3;\n\n    if (this._config && this._config.tooltips === false) {\n      return false;\n    }\n\n    const result = ((_this$_config3 = this._config) === null || _this$_config3 === void 0 ? void 0 : _this$_config3.tooltips) || {};\n\n    if (result.position === undefined) {\n      result.position = 'top';\n    } else if (['top', 'right', 'bottom', 'left'].indexOf(result.position) === -1) {\n      throw new Error(i18n.translate('visTypeVega.vegaParser.unexpectedValueForPositionConfigurationErrorMessage', {\n        defaultMessage: 'Unexpected value for the {configurationName} configuration',\n        values: {\n          configurationName: 'result.position'\n        }\n      }));\n    }\n\n    if (result.padding === undefined) {\n      result.padding = 16;\n    } else if (typeof result.padding !== 'number') {\n      throw new Error(i18n.translate('visTypeVega.vegaParser.paddingConfigValueTypeErrorMessage', {\n        defaultMessage: '{configName} is expected to be a number',\n        values: {\n          configName: 'config.kibana.result.padding'\n        }\n      }));\n    }\n\n    if (result.textTruncate === undefined) {\n      result.textTruncate = false;\n    } else if (typeof result.textTruncate !== 'boolean') {\n      throw new Error(i18n.translate('visTypeVega.vegaParser.textTruncateConfigValueTypeErrorMessage', {\n        defaultMessage: '{configName} is expected to be a boolean',\n        values: {\n          configName: 'textTruncate'\n        }\n      }));\n    }\n\n    if (result.centerOnMark === undefined) {\n      // if mark's width & height is less than this value, center on it\n      result.centerOnMark = 50;\n    } else if (typeof result.centerOnMark === 'boolean') {\n      result.centerOnMark = result.centerOnMark ? Number.MAX_VALUE : -1;\n    } else if (typeof result.centerOnMark !== 'number') {\n      throw new Error(i18n.translate('visTypeVega.vegaParser.centerOnMarkConfigValueTypeErrorMessage', {\n        defaultMessage: '{configName} is expected to be {trueValue}, {falseValue}, or a number',\n        values: {\n          configName: 'config.kibana.result.centerOnMark',\n          trueValue: 'true',\n          falseValue: 'false'\n        }\n      }));\n    }\n\n    return result;\n  }\n  /**\n   * Parse map-specific configuration\n   * @returns {{mapStyle: *|string, delayRepaint: boolean, latitude: number, longitude: number, zoom, minZoom, maxZoom, zoomControl: *|boolean, maxBounds: *}}\n   * @private\n   */\n\n\n  _parseMapConfig() {\n    var _this$_config4, _this$_config6;\n\n    const res = {\n      delayRepaint: ((_this$_config4 = this._config) === null || _this$_config4 === void 0 ? void 0 : _this$_config4.delayRepaint) === undefined ? true : this._config.delayRepaint\n    };\n\n    const validate = (name, isZoom) => {\n      const val = this._config ? this._config[name] : undefined;\n\n      if (val !== undefined) {\n        const parsed = parseFloat(val);\n\n        if (Number.isFinite(parsed) && (!isZoom || parsed >= 0 && parsed <= 30)) {\n          res[name] = parsed;\n          return;\n        }\n\n        this._onWarning(i18n.translate('visTypeVega.vegaParser.someKibanaConfigurationIsNoValidWarningMessage', {\n          defaultMessage: '{configName} is not valid',\n          values: {\n            configName: `config.kibana.${name}`\n          }\n        }));\n      }\n\n      if (!isZoom) res[name] = 0;\n    };\n\n    validate(`latitude`, false);\n    validate(`longitude`, false);\n    validate(`zoom`, true);\n    validate(`minZoom`, true);\n    validate(`maxZoom`, true);\n\n    this._parseBool('mapStyle', res, true);\n\n    if (res.mapStyle) {\n      var _this$_config5;\n\n      res.emsTileServiceId = (_this$_config5 = this._config) === null || _this$_config5 === void 0 ? void 0 : _this$_config5.emsTileServiceId;\n    }\n\n    this._parseBool('zoomControl', res, true);\n\n    this._parseBool('scrollWheelZoom', res, false);\n\n    const maxBounds = (_this$_config6 = this._config) === null || _this$_config6 === void 0 ? void 0 : _this$_config6.maxBounds;\n\n    if (maxBounds !== undefined) {\n      if (!Array.isArray(maxBounds) || maxBounds.length !== 4 || !maxBounds.every(v => typeof v === 'number' && Number.isFinite(v))) {\n        this._onWarning(i18n.translate('visTypeVega.vegaParser.maxBoundsValueTypeWarningMessage', {\n          defaultMessage: '{maxBoundsConfigName} must be an array with four numbers',\n          values: {\n            maxBoundsConfigName: 'config.kibana.maxBounds'\n          }\n        }));\n      } else {\n        res.maxBounds = maxBounds;\n      }\n    }\n\n    return res;\n  }\n\n  _parseBool(paramName, dstObj, dflt) {\n    const val = this._config ? this._config[paramName] : undefined;\n\n    if (val === undefined) {\n      dstObj[paramName] = dflt;\n    } else if (typeof val !== 'boolean') {\n      this._onWarning(i18n.translate('visTypeVega.vegaParser.someKibanaParamValueTypeWarningMessage', {\n        defaultMessage: '{configName} must be a boolean value',\n        values: {\n          configName: `config.kibana.${paramName}`\n        }\n      }));\n\n      dstObj[paramName] = dflt;\n    } else {\n      dstObj[paramName] = val;\n    }\n  }\n  /**\n   * Parse Vega schema element\n   * @returns {object} isVegaLite, libVersion\n   * @private\n   */\n\n\n  parseSchema(spec) {\n    const schema = schemaParser(spec.$schema);\n    const isVegaLite = schema.library === 'vega-lite';\n    const libVersion = isVegaLite ? vegaLiteVersion : vegaVersion;\n\n    if (versionCompare(schema.version, libVersion) > 0) {\n      this._onWarning(i18n.translate('visTypeVega.vegaParser.notValidLibraryVersionForInputSpecWarningMessage', {\n        defaultMessage: 'The input spec uses {schemaLibrary} {schemaVersion}, but current version of {schemaLibrary} is {libraryVersion}.',\n        values: {\n          schemaLibrary: schema.library,\n          schemaVersion: schema.version,\n          libraryVersion: libVersion\n        }\n      }));\n    }\n\n    return {\n      isVegaLite,\n      libVersion\n    };\n  }\n  /**\n   * Replace all instances of ES requests with raw values.\n   * Also handle any other type of url: {type: xxx, ...}\n   * @private\n   */\n\n\n  async _resolveDataUrls() {\n    if (!this._urlParsers) {\n      const serviceSettings = await this.getServiceSettings();\n\n      const onWarn = this._onWarning.bind(this);\n\n      this._urlParsers = {\n        elasticsearch: new EsQueryParser(this.timeCache, this.searchAPI, this.filters, onWarn),\n        emsfile: new EmsFileParser(serviceSettings),\n        url: new UrlParser(onWarn)\n      };\n    }\n\n    const pending = {};\n    this.searchAPI.resetSearchStats();\n\n    this._findObjectDataUrls(this.spec, obj => {\n      const url = obj.url;\n      delete obj.url;\n      let type = url['%type%'];\n      delete url['%type%'];\n\n      if (type === undefined) {\n        type = DEFAULT_PARSER;\n      }\n\n      const parser = this._urlParsers[type];\n\n      if (parser === undefined) {\n        throw new Error(i18n.translate('visTypeVega.vegaParser.notSupportedUrlTypeErrorMessage', {\n          defaultMessage: '{urlObject} is not supported',\n          values: {\n            urlObject: 'url: {\"%type%\": \"${type}\"}'\n          }\n        }));\n      }\n\n      let pendingArr = pending[type];\n\n      if (pendingArr === undefined) {\n        pending[type] = pendingArr = [];\n      }\n\n      pendingArr.push(parser.parseUrl(obj, url));\n    });\n\n    const pendingParsers = Object.keys(pending);\n\n    if (pendingParsers.length > 0) {\n      // let each parser populate its data in parallel\n      await Promise.all(pendingParsers.map(type => this._urlParsers[type].populateData(pending[type])));\n    }\n  }\n  /**\n   * Recursively find and callback every instance of the data.url as an object\n   * @param {*} obj current location in the object tree\n   * @param {function({object})} onFind Call this function for all url objects\n   * @param {string} [key] field name of the current object\n   * @private\n   */\n\n\n  _findObjectDataUrls(obj, onFind, key) {\n    if (Array.isArray(obj)) {\n      for (const elem of obj) {\n        this._findObjectDataUrls(elem, onFind, key);\n      }\n    } else if (_.isPlainObject(obj)) {\n      if (key === 'data' && _.isPlainObject(obj.url)) {\n        // Assume that any  \"data\": {\"url\": {...}}  is a request for data\n        if (obj.values !== undefined || obj.source !== undefined) {\n          throw new Error(i18n.translate('visTypeVega.vegaParser.dataExceedsSomeParamsUseTimesLimitErrorMessage', {\n            defaultMessage: 'Data must not have more than one of {urlParam}, {valuesParam}, and {sourceParam}',\n            values: {\n              urlParam: '\"url\"',\n              valuesParam: '\"values\"',\n              sourceParam: '\"source\"'\n            }\n          }));\n        }\n\n        onFind(obj);\n      } else {\n        for (const k of Object.keys(obj)) {\n          this._findObjectDataUrls(obj[k], onFind, k);\n        }\n      }\n    }\n  }\n  /**\n   * Inject default colors into the spec.config\n   * @private\n   */\n\n\n  _setDefaultColors() {\n    // Default category coloring to the Elastic color scheme\n    this._setDefaultValue({\n      scheme: 'elastic'\n    }, 'config', 'range', 'category');\n\n    if (this.isVegaLite) {\n      // Vega-Lite: set default color, works for fill and strike --  config: { mark:  { color: '#54B399' }}\n      this._setDefaultValue(defaultColor, 'config', 'mark', 'color');\n    } else {\n      var _this$spec;\n\n      // Vega - global mark has very strange behavior, must customize each mark type individually\n      // https://github.com/vega/vega/issues/1083\n      // Don't set defaults if spec.config.mark.color or fill are set\n      if (!((_this$spec = this.spec) !== null && _this$spec !== void 0 && _this$spec.config.mark) || this.spec.config.mark.color === undefined && this.spec.config.mark.fill === undefined) {\n        this._setDefaultValue(defaultColor, 'config', 'arc', 'fill');\n\n        this._setDefaultValue(defaultColor, 'config', 'area', 'fill');\n\n        this._setDefaultValue(defaultColor, 'config', 'line', 'stroke');\n\n        this._setDefaultValue(defaultColor, 'config', 'path', 'stroke');\n\n        this._setDefaultValue(defaultColor, 'config', 'rect', 'fill');\n\n        this._setDefaultValue(defaultColor, 'config', 'rule', 'stroke');\n\n        this._setDefaultValue(defaultColor, 'config', 'shape', 'stroke');\n\n        this._setDefaultValue(defaultColor, 'config', 'symbol', 'fill');\n\n        this._setDefaultValue(defaultColor, 'config', 'trail', 'fill');\n      }\n    } // provide right colors for light and dark themes\n\n\n    this._setDefaultValue(euiThemeVars.euiColorDarkestShade, 'config', 'title', 'color');\n\n    this._setDefaultValue(euiThemeVars.euiColorDarkShade, 'config', 'style', 'guide-label', 'fill');\n\n    this._setDefaultValue(euiThemeVars.euiColorDarkestShade, 'config', 'style', 'guide-title', 'fill');\n\n    this._setDefaultValue(euiThemeVars.euiColorDarkestShade, 'config', 'style', 'group-title', 'fill');\n\n    this._setDefaultValue(euiThemeVars.euiColorDarkestShade, 'config', 'style', 'group-subtitle', 'fill');\n\n    this._setDefaultValue(euiThemeVars.euiColorChartLines, 'config', 'axis', 'tickColor');\n\n    this._setDefaultValue(euiThemeVars.euiColorChartLines, 'config', 'axis', 'domainColor');\n\n    this._setDefaultValue(euiThemeVars.euiColorChartLines, 'config', 'axis', 'gridColor');\n\n    this._setDefaultValue('transparent', 'config', 'background');\n  }\n  /**\n   * Set default value if it doesn't exist.\n   * Given an object, and an array of fields, ensure that obj.fld1.fld2. ... .fldN is set to value if it doesn't exist.\n   * @param {*} value\n   * @param {string} fields\n   * @private\n   */\n\n\n  _setDefaultValue(value, ...fields) {\n    let o = this.spec;\n\n    for (let i = 0; i < fields.length - 1; i++) {\n      const field = fields[i];\n      const subObj = o[field];\n\n      if (subObj === undefined) {\n        o[field] = {};\n      } else if (!_.isPlainObject(subObj)) {\n        return;\n      }\n\n      o = o[field];\n    }\n\n    const lastField = fields[fields.length - 1];\n\n    if (o[lastField] === undefined) {\n      o[lastField] = value;\n    }\n  }\n  /**\n   * Add a warning to the warnings array\n   * @private\n   */\n\n\n  _onWarning(...args) {\n    if (!this.hideWarnings) {\n      this.warnings.push(Utils.formatWarningToStr(args));\n      return Utils.formatWarningToStr(args);\n    }\n  }\n\n}","function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\nimport { i18n } from '@kbn/i18n'; // @ts-ignore\n\nimport { bypassExternalUrlCheck } from '../chart_view/chart_view';\n\n/**\n * This class processes all Chart spec customizations,\n * converting url object parameters into query results.\n */\nexport class EmsFileParser {\n  constructor(serviceSettings) {\n    _defineProperty(this, \"_serviceSettings\", void 0);\n\n    _defineProperty(this, \"_fileLayersP\", void 0);\n\n    this._serviceSettings = serviceSettings;\n  } // noinspection JSMethodCanBeStatic\n\n  /**\n   * Update request object, expanding any context-aware keywords\n   */\n\n\n  parseUrl(obj, url) {\n    if (typeof url.name !== 'string') {\n      throw new Error(i18n.translate('visTypeChart.emsFileParser.missingNameOfFileErrorMessage', {\n        defaultMessage: '{dataUrlParam} with {dataUrlParamValue} requires {nameParam} parameter (name of the file)',\n        values: {\n          dataUrlParam: '\"data.url\"',\n          dataUrlParamValue: '{\"%type%\": \"emsfile\"}',\n          nameParam: '\"name\"'\n        }\n      }));\n    } // Optimization: so initiate remote request as early as we know that we will need it\n\n\n    if (!this._fileLayersP) {\n      this._fileLayersP = this._serviceSettings.getFileLayers();\n    }\n\n    return {\n      obj,\n      name: url.name\n    };\n  }\n  /**\n   * Process items generated by parseUrl()\n   * @param {object[]} requests each object is generated by parseUrl()\n   * @returns {Promise<void>}\n   */\n\n\n  async populateData(requests) {\n    if (requests.length === 0) return;\n    const layers = await this._fileLayersP;\n\n    for (const {\n      obj,\n      name\n    } of requests) {\n      const foundLayer = layers === null || layers === void 0 ? void 0 : layers.find(v => v.name === name);\n\n      if (!foundLayer) {\n        throw new Error(i18n.translate('visTypeChart.emsFileParser.emsFileNameDoesNotExistErrorMessage', {\n          defaultMessage: '{emsfile} {emsfileName} does not exist',\n          values: {\n            emsfileName: JSON.stringify(name),\n            emsfile: 'emsfile'\n          }\n        }));\n      } // This URL can bypass loader sanitization at the later stage\n\n\n      const url = await this._serviceSettings.getUrlForRegionLayer(foundLayer);\n      obj.url = bypassExternalUrlCheck(url);\n    }\n  }\n\n}","function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\nimport moment from 'moment';\nimport { i18n } from '@kbn/i18n';\nimport { cloneDeep, isPlainObject } from 'lodash';\nconst TIMEFILTER = '%timefilter%';\nconst AUTOINTERVAL = '%autointerval%';\nconst MUST_CLAUSE = '%dashboard_context-must_clause%';\nconst MUST_NOT_CLAUSE = '%dashboard_context-must_not_clause%';\nconst FILTER_CLAUSE = '%dashboard_context-filter_clause%'; // These values may appear in the  'url': { ... }  object\n\nconst LEGACY_CONTEXT = '%context_query%';\nconst CONTEXT = '%context%';\nconst TIMEFIELD = '%timefield%';\n\nconst getRequestName = (request, index) => request.dataObject.name || i18n.translate('visTypeVega.esQueryParser.unnamedRequest', {\n  defaultMessage: 'Unnamed request #{index}',\n  values: {\n    index\n  }\n});\n/**\n * This class parses ES requests specified in the data.url objects.\n */\n\n\nexport class EsQueryParser {\n  constructor(timeCache, searchAPI, filters, onWarning) {\n    _defineProperty(this, \"_timeCache\", void 0);\n\n    _defineProperty(this, \"_searchAPI\", void 0);\n\n    _defineProperty(this, \"_filters\", void 0);\n\n    _defineProperty(this, \"_onWarning\", void 0);\n\n    this._timeCache = timeCache;\n    this._searchAPI = searchAPI;\n    this._filters = filters;\n    this._onWarning = onWarning;\n  } // noinspection JSMethodCanBeStatic\n\n  /**\n   * Update request object, expanding any context-aware keywords\n   */\n\n\n  parseUrl(dataObject, url) {\n    let body = url.body;\n    let context = url[CONTEXT];\n    delete url[CONTEXT];\n    let timefield = url[TIMEFIELD];\n    delete url[TIMEFIELD];\n    let usesContext = context !== undefined || timefield !== undefined;\n\n    if (body === undefined) {\n      url.body = body = {};\n    } else if (!isPlainObject(body)) {\n      throw new Error(i18n.translate('visTypeVega.esQueryParser.urlBodyValueTypeErrorMessage', {\n        defaultMessage: '{configName} must be an object',\n        values: {\n          configName: 'url.body'\n        }\n      }));\n    } // Migrate legacy %context_query% into context & timefield values\n\n\n    const legacyContext = url[LEGACY_CONTEXT];\n    delete url[LEGACY_CONTEXT];\n\n    if (legacyContext !== undefined) {\n      if (body.query !== undefined) {\n        throw new Error(i18n.translate('visTypeVega.esQueryParser.dataUrlMustNotHaveLegacyAndBodyQueryValuesAtTheSameTimeErrorMessage', {\n          defaultMessage: '{dataUrlParam} must not have legacy {legacyContext} and {bodyQueryConfigName} values at the same time',\n          values: {\n            legacyContext: `\"${LEGACY_CONTEXT}\"`,\n            bodyQueryConfigName: '\"body.query\"',\n            dataUrlParam: '\"data.url\"'\n          }\n        }));\n      } else if (usesContext) {\n        throw new Error(i18n.translate('visTypeVega.esQueryParser.dataUrlMustNotHaveLegacyContextTogetherWithContextOrTimefieldErrorMessage', {\n          defaultMessage: '{dataUrlParam} must not have {legacyContext} together with {context} or {timefield}',\n          values: {\n            legacyContext: `\"${LEGACY_CONTEXT}\"`,\n            context: `\"${CONTEXT}\"`,\n            timefield: `\"${TIMEFIELD}\"`,\n            dataUrlParam: '\"data.url\"'\n          }\n        }));\n      } else if (legacyContext !== true && (typeof legacyContext !== 'string' || legacyContext.length === 0)) {\n        throw new Error(i18n.translate('visTypeVega.esQueryParser.legacyContextCanBeTrueErrorMessage', {\n          defaultMessage: 'Legacy {legacyContext} can either be {trueValue} (ignores time range picker), or it can be the name of the time field, e.g. {timestampParam}',\n          values: {\n            legacyContext: `\"${LEGACY_CONTEXT}\"`,\n            trueValue: 'true',\n            timestampParam: '\"@timestamp\"'\n          }\n        }));\n      }\n\n      usesContext = true;\n      context = true;\n      let result = `\"url\": {\"${CONTEXT}\": true`;\n\n      if (typeof legacyContext === 'string') {\n        timefield = legacyContext;\n        result += `, \"${TIMEFIELD}\": ${JSON.stringify(timefield)}`;\n      }\n\n      result += '}';\n\n      this._onWarning(i18n.translate('visTypeVega.esQueryParser.legacyUrlShouldChangeToWarningMessage', {\n        defaultMessage: 'Legacy {urlParam}: {legacyUrl} should change to {result}',\n        values: {\n          legacyUrl: `\"${LEGACY_CONTEXT}\": ${JSON.stringify(legacyContext)}`,\n          result,\n          urlParam: '\"url\"'\n        }\n      }));\n    }\n\n    if (body.query !== undefined) {\n      if (usesContext) {\n        throw new Error(i18n.translate('visTypeVega.esQueryParser.urlContextAndUrlTimefieldMustNotBeUsedErrorMessage', {\n          defaultMessage: '{urlContext} and {timefield} must not be used when {queryParam} is set',\n          values: {\n            timefield: `url.${TIMEFIELD}`,\n            urlContext: `url.${CONTEXT}`,\n            queryParam: 'url.body.query'\n          }\n        }));\n      }\n\n      this._injectContextVars(body.query, true);\n    } else if (usesContext) {\n      if (timefield) {\n        // Inject range filter based on the timefilter values\n        body.query = {\n          range: {\n            [timefield]: this._createRangeFilter({\n              [TIMEFILTER]: true\n            })\n          }\n        };\n      }\n\n      if (context) {\n        // Use dashboard context\n        const newQuery = cloneDeep(this._filters);\n\n        if (timefield) {\n          newQuery.bool.must.push(body.query);\n        }\n\n        body.query = newQuery;\n      }\n    }\n\n    this._injectContextVars(body.aggs, false);\n\n    return {\n      dataObject,\n      url\n    };\n  }\n  /**\n   * Process items generated by parseUrl()\n   * @param {object[]} requests each object is generated by parseUrl()\n   * @returns {Promise<void>}\n   */\n\n\n  async populateData(requests) {\n    const esSearches = requests.map((r, index) => ({ ...r.url,\n      name: getRequestName(r, index)\n    }));\n\n    const data$ = this._searchAPI.search(esSearches);\n\n    const results = await data$.toPromise();\n    results.forEach((data, index) => {\n      const requestObject = requests.find(item => getRequestName(item, index) === data.name);\n\n      if (requestObject) {\n        requestObject.dataObject.url = requestObject.url;\n        requestObject.dataObject.values = data.rawResponse;\n      }\n    });\n  }\n  /**\n   * Modify ES request by processing magic keywords\n   * @param {*} obj\n   * @param {boolean} isQuery - if true, the `obj` belongs to the req's query portion\n   */\n\n\n  _injectContextVars(obj, isQuery) {\n    if (obj && typeof obj === 'object') {\n      if (Array.isArray(obj)) {\n        // For arrays, replace MUST_CLAUSE and MUST_NOT_CLAUSE string elements\n        for (let pos = 0; pos < obj.length;) {\n          const item = obj[pos];\n\n          if (isQuery && (item === FILTER_CLAUSE || item === MUST_CLAUSE || item === MUST_NOT_CLAUSE)) {\n            let ctxTag = '';\n\n            switch (item) {\n              case FILTER_CLAUSE:\n                ctxTag = 'filter';\n                break;\n\n              case MUST_CLAUSE:\n                ctxTag = 'must';\n                break;\n\n              case MUST_NOT_CLAUSE:\n                ctxTag = 'must_not';\n                break;\n            }\n\n            const ctx = cloneDeep(this._filters);\n\n            if (ctx && ctx.bool && ctx.bool[ctxTag]) {\n              if (Array.isArray(ctx.bool[ctxTag])) {\n                // replace one value with an array of values\n                obj.splice(pos, 1, ...ctx.bool[ctxTag]);\n                pos += ctx.bool[ctxTag].length;\n              } else {\n                obj[pos++] = ctx.bool[ctxTag];\n              }\n            } else {\n              obj.splice(pos, 1); // remove item, keep pos at the same position\n            }\n          } else {\n            this._injectContextVars(item, isQuery);\n\n            pos++;\n          }\n        }\n      } else {\n        for (const prop of Object.keys(obj)) {\n          const subObj = obj[prop];\n          if (!subObj || typeof obj !== 'object') continue; // replace \"interval\": { \"%autointerval%\": true|integer } with\n          // auto-generated range based on the timepicker\n\n          if (prop === 'interval' && subObj[AUTOINTERVAL]) {\n            let size = subObj[AUTOINTERVAL];\n\n            if (size === true) {\n              size = 50; // by default, try to get ~80 values\n            } else if (typeof size !== 'number') {\n              throw new Error(i18n.translate('visTypeVega.esQueryParser.autointervalValueTypeErrorMessage', {\n                defaultMessage: '{autointerval} must be either {trueValue} or a number',\n                values: {\n                  autointerval: `\"${AUTOINTERVAL}\"`,\n                  trueValue: 'true'\n                }\n              }));\n            }\n\n            const bounds = this._timeCache.getTimeBounds();\n\n            obj.interval = EsQueryParser._roundInterval((bounds.max - bounds.min) / size);\n            continue;\n          } // handle %timefilter%\n\n\n          switch (subObj[TIMEFILTER]) {\n            case 'min':\n            case 'max':\n              // Replace {\"%timefilter%\": \"min|max\", ...} object with a timestamp\n              obj[prop] = this._getTimeBound(subObj, subObj[TIMEFILTER]);\n              continue;\n\n            case true:\n              // Replace {\"%timefilter%\": true, ...} object with the \"range\" object\n              this._createRangeFilter(subObj);\n\n              continue;\n\n            case undefined:\n              this._injectContextVars(subObj, isQuery);\n\n              continue;\n\n            default:\n              throw new Error(i18n.translate('visTypeVega.esQueryParser.timefilterValueErrorMessage', {\n                defaultMessage: '{timefilter} property must be set to {trueValue}, {minValue}, or {maxValue}',\n                values: {\n                  timefilter: `\"${TIMEFILTER}\"`,\n                  trueValue: 'true',\n                  minValue: '\"min\"',\n                  maxValue: '\"max\"'\n                }\n              }));\n          }\n        }\n      }\n    }\n  }\n  /**\n   * replaces given object that contains `%timefilter%` key with the timefilter bounds and optional shift & unit parameters\n   * @param {object} obj\n   * @return {object}\n   */\n\n\n  _createRangeFilter(obj) {\n    obj.gte = moment(this._getTimeBound(obj, 'min')).toISOString();\n    obj.lte = moment(this._getTimeBound(obj, 'max')).toISOString();\n    obj.format = 'strict_date_optional_time';\n    delete obj[TIMEFILTER];\n    delete obj.shift;\n    delete obj.unit;\n    return obj;\n  }\n  /**\n   *\n   * @param {object} opts\n   * @param {number} [opts.shift]\n   * @param {string} [opts.unit]\n   * @param {'min'|'max'} type\n   * @returns {*}\n   */\n\n\n  _getTimeBound(opts, type) {\n    var _bounds$type;\n\n    const bounds = this._timeCache.getTimeBounds();\n\n    let result = ((_bounds$type = bounds[type]) === null || _bounds$type === void 0 ? void 0 : _bounds$type.valueOf()) || 0;\n\n    if (opts.shift) {\n      const shift = opts.shift;\n\n      if (typeof shift !== 'number') {\n        throw new Error(i18n.translate('visTypeVega.esQueryParser.shiftMustValueTypeErrorMessage', {\n          defaultMessage: '{shiftParam} must be a numeric value',\n          values: {\n            shiftParam: '\"shift\"'\n          }\n        }));\n      }\n\n      let multiplier;\n\n      switch (opts.unit || 'd') {\n        case 'w':\n        case 'week':\n          multiplier = 1000 * 60 * 60 * 24 * 7;\n          break;\n\n        case 'd':\n        case 'day':\n          multiplier = 1000 * 60 * 60 * 24;\n          break;\n\n        case 'h':\n        case 'hour':\n          multiplier = 1000 * 60 * 60;\n          break;\n\n        case 'm':\n        case 'minute':\n          multiplier = 1000 * 60;\n          break;\n\n        case 's':\n        case 'second':\n          multiplier = 1000;\n          break;\n\n        default:\n          throw new Error(i18n.translate('visTypeVega.esQueryParser.unknownUnitValueErrorMessage', {\n            defaultMessage: 'Unknown {unitParamName} value. Must be one of: [{unitParamValues}]',\n            values: {\n              unitParamName: '\"unit\"',\n              unitParamValues: '\"week\", \"day\", \"hour\", \"minute\", \"second\"'\n            }\n          }));\n      }\n\n      result += shift * multiplier;\n    }\n\n    return result;\n  }\n  /**\n   * Adapted from src/legacy/core_plugins/timelion/common/lib/calculate_interval.js\n   * @param interval (ms)\n   * @returns {string}\n   */\n\n\n  static _roundInterval(interval) {\n    switch (true) {\n      case interval <= 500:\n        // <= 0.5s\n        return '100ms';\n\n      case interval <= 5000:\n        // <= 5s\n        return '1s';\n\n      case interval <= 7500:\n        // <= 7.5s\n        return '5s';\n\n      case interval <= 15000:\n        // <= 15s\n        return '10s';\n\n      case interval <= 45000:\n        // <= 45s\n        return '30s';\n\n      case interval <= 180000:\n        // <= 3m\n        return '1m';\n\n      case interval <= 450000:\n        // <= 9m\n        return '5m';\n\n      case interval <= 1200000:\n        // <= 20m\n        return '10m';\n\n      case interval <= 2700000:\n        // <= 45m\n        return '30m';\n\n      case interval <= 7200000:\n        // <= 2h\n        return '1h';\n\n      case interval <= 21600000:\n        // <= 6h\n        return '3h';\n\n      case interval <= 86400000:\n        // <= 24h\n        return '12h';\n\n      case interval <= 604800000:\n        // <= 1w\n        return '24h';\n\n      case interval <= 1814400000:\n        // <= 3w\n        return '1w';\n\n      case interval < 3628800000:\n        // <  2y\n        return '30d';\n\n      default:\n        return '1y';\n    }\n  }\n\n}","function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\nimport $ from 'jquery';\nimport { i18n } from '@kbn/i18n';\n\n/**\n * This class processes all Vega spec customizations,\n * converting url object parameters into query results.\n */\nexport class UrlParser {\n  constructor(onWarning) {\n    _defineProperty(this, \"_onWarning\", void 0);\n\n    this._onWarning = onWarning;\n  } // noinspection JSMethodCanBeStatic\n\n  /**\n   * Update request object\n   */\n\n\n  parseUrl(obj, urlObj) {\n    let url = urlObj.url;\n\n    if (!url) {\n      throw new Error(i18n.translate('visTypeVega.urlParser.dataUrlRequiresUrlParameterInFormErrorMessage', {\n        defaultMessage: '{dataUrlParam} requires a {urlParam} parameter in a form \"{formLink}\"',\n        values: {\n          dataUrlParam: '\"data.url\"',\n          urlParam: '\"url\"',\n          formLink: 'https://example.org/path/subpath'\n        }\n      }));\n    }\n\n    const query = urlObj.query;\n\n    if (!query) {\n      this._onWarning(i18n.translate('visTypeVega.urlParser.urlShouldHaveQuerySubObjectWarningMessage', {\n        defaultMessage: 'Using a {urlObject} should have a {subObjectName} sub-object',\n        values: {\n          urlObject: '\"url\": {\"%type%\": \"url\", \"url\": ...}',\n          subObjectName: '\"query\"'\n        }\n      }));\n    } else {\n      url += (url.includes('?') ? '&' : '?') + $.param(query);\n    }\n\n    obj.url = url;\n  }\n  /**\n   * No-op - the url is already set during the parseUrl\n   */\n\n\n  populateData() {}\n\n}"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA,WAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9GA;AACA;;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7vBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}