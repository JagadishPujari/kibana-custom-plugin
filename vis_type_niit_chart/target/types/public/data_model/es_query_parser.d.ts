import type { estypes } from '@elastic/elasticsearch';
import { TimeCache } from './time_cache';
import { SearchAPI } from './search_api';
import { Opts, Type, Data, UrlObject, Bool, EsQueryRequest, Query } from './types';
/**
 * This class parses ES requests specified in the data.url objects.
 */
export declare class EsQueryParser {
    _timeCache: TimeCache;
    _searchAPI: SearchAPI;
    _filters: Bool;
    _onWarning: (...args: string[]) => void;
    constructor(timeCache: TimeCache, searchAPI: SearchAPI, filters: Bool, onWarning: (...args: string[]) => void);
    /**
     * Update request object, expanding any context-aware keywords
     */
    parseUrl(dataObject: Data, url: UrlObject): {
        dataObject: Data;
        url: UrlObject;
    };
    /**
     * Process items generated by parseUrl()
     * @param {object[]} requests each object is generated by parseUrl()
     * @returns {Promise<void>}
     */
    populateData(requests: EsQueryRequest[]): Promise<void>;
    /**
     * Modify ES request by processing magic keywords
     * @param {*} obj
     * @param {boolean} isQuery - if true, the `obj` belongs to the req's query portion
     */
    _injectContextVars(obj: Query | estypes.SearchRequest['body']['aggs'], isQuery: boolean): void;
    /**
     * replaces given object that contains `%timefilter%` key with the timefilter bounds and optional shift & unit parameters
     * @param {object} obj
     * @return {object}
     */
    _createRangeFilter(obj: Opts): Opts;
    /**
     *
     * @param {object} opts
     * @param {number} [opts.shift]
     * @param {string} [opts.unit]
     * @param {'min'|'max'} type
     * @returns {*}
     */
    _getTimeBound(opts: Opts, type: Type): number;
    /**
     * Adapted from src/legacy/core_plugins/timelion/common/lib/calculate_interval.js
     * @param interval (ms)
     * @returns {string}
     */
    static _roundInterval(interval: number): string;
}
//# sourceMappingURL=es_query_parser.d.ts.map